#pragma kernel CSMain
#define THREADS 256

#include "UnityCG.cginc"

float hash(float n) {
	return frac(sin(n) * 43758.5453);
}

// The noise function returns a value in the range -1.0f -> 1.0f
float noise1(float3 x) {
	float3 p = floor(x);
	float3 f = frac(x);

	f = f * f * (3.0 - 2.0 * f);
	float n = p.x + p.y * 57.0 + 113.0 * p.z;

	return lerp(lerp(lerp(hash(n + 0.0), hash(n + 1.0), f.x),
	                 lerp(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
	            lerp(lerp(hash(n + 113.0), hash(n + 114.0), f.x),
	                 lerp(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
}

float2 norm(float2 v) {
	float l = length(v);
	return (l < 1) ? v : v / l;
}

struct Boid
{
	float2 position;
	float2 direction;
	float2 target_pos;
	float noise_offset;
	uint team;
	int targeted_unit;
};

RWStructuredBuffer<Boid> boidBuffer;

CBUFFER_START(Params)
float DeltaTime;
float RotationSpeed;
float BoidSpeed;
float BoidSpeedVariation;
float NeighbourDistance;
uint BoidsCount;
CBUFFER_END

[numthreads(THREADS,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
	uint instanceId = id.x;
	Boid boid = boidBuffer[instanceId];

	float noise = clamp(noise1(_Time / 100.0 + boid.noise_offset), -1, 1) * 2.0 - 1.0;
	//float velocity = BoidSpeed * (1.0 + noise * BoidSpeedVariation);
	float velocity = BoidSpeed;

	float2 boid_pos = boid.position;
	float2 boid_dir = boid.direction;

	float2 separation = float2(0.0, 0.0);
	float2 to_target = boid.target_pos;

	uint nearbyCount = 1; // Add self that is ignored in loop
	float minSqrDist = NeighbourDistance * NeighbourDistance;
	boid.targeted_unit = -1;
	
	for (uint i = 0; i < BoidsCount; i++)
	{
		if (i == instanceId)
			continue;
		
		if (distance(boid_pos, boidBuffer[i].position) < NeighbourDistance)
		{
			if(boidBuffer[i].team != boid.team)
			{
				float2 diff_enemy = boid_pos - boidBuffer[i].position;
				float sqrDist = dot(diff_enemy, diff_enemy);
				if (sqrDist < minSqrDist)
				{
					boid.targeted_unit = i;
					minSqrDist = sqrDist;
				}
			}
			float2 tempBoid_position = boidBuffer[i].position;

			float2 diff = boid_pos - tempBoid_position;
			float diffLen = (length(diff));
			float scaler = clamp(1.0 - diffLen / NeighbourDistance, 0.0, 1.0);

			separation += diff * (scaler / diffLen);


			nearbyCount += 1;
		}
	}


	//float avg = 1.0 / nearbyCount;
	//cohesion *= avg;
	


	to_target = norm(to_target - boid_pos);
	//separation = norm(separation);

	float2 direction = separation+ to_target;

	//float ip = exp();
	//boid.direction = lerp((direction), normalize(boid_dir), -RotationSpeed * DeltaTime);
	boid.direction = norm(direction);

	boid.position += (boid.direction) * (velocity * DeltaTime);

	boidBuffer[id.x] = boid;
}
